const std = @import("std");

// Parse version string like "0.1.0" into numeric format
// Format: Major * 1_000_000 + Minor * 1_000 + Patch
fn parseVersionString(version_str: []const u8) struct { major: u32, minor: u32, patch: u32, numeric: u32 } {
    var parts = std.mem.splitSequence(u8, version_str, ".");
    const major_str = parts.next() orelse "0";
    const minor_str = parts.next() orelse "0";
    const patch_str = parts.next() orelse "0";
    
    const major = std.fmt.parseInt(u32, major_str, 10) catch 0;
    const minor = std.fmt.parseInt(u32, minor_str, 10) catch 0;
    const patch = std.fmt.parseInt(u32, patch_str, 10) catch 0;
    
    const numeric = major * 1_000_000 + minor * 1_000 + patch;
    
    return .{ .major = major, .minor = minor, .patch = patch, .numeric = numeric };
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    
    // Read and parse version from build.zig.zon
    const zon_path = b.pathFromRoot("build.zig.zon");
    const zon_content = std.fs.cwd().readFileAlloc(b.allocator, zon_path, std.math.maxInt(usize)) catch |err| {
        std.log.err("Failed to read build.zig.zon: {}", .{err});
        @panic("Could not read build.zig.zon");
    };
    defer b.allocator.free(zon_content);
    
    // Parse version from build.zig.zon - look for .version = "..." on its own line
    const version_str = blk: {
        const pattern = "\n    .version = \"";
        const alt_pattern = ".version = \"";
        
        // Try the more specific pattern first (with newline and indentation)
        const search_start = if (std.mem.indexOf(u8, zon_content, pattern)) |start|
            start + pattern.len
        else if (std.mem.indexOf(u8, zon_content, alt_pattern)) |start|
            start + alt_pattern.len
        else
            @panic("Could not find version field in build.zig.zon");
        
        // Find the closing quote
        if (std.mem.indexOfScalarPos(u8, zon_content, search_start, '"')) |end| {
            const version_slice = zon_content[search_start..end];
            // Allocate a copy that will persist
            const version = b.allocator.dupe(u8, version_slice) catch @panic("Out of memory");
            break :blk version;
        }
        
        @panic("Could not parse version value in build.zig.zon");
    };
    const version_info = parseVersionString(version_str);
    
    // Generate version.zig file with unified naming
    const version_file_content = std.fmt.allocPrint(
        b.allocator,
        \\// This file is auto-generated by build.zig from build.zig.zon
        \\// Do not edit manually - edit build.zig.zon instead
        \\
        \\/// Zorg version string (e.g., "0.1.0")
        \\/// This is automatically generated from build.zig.zon
        \\pub const ZORG_VERSION: []const u8 = "{s}";
        \\
        \\/// Target Zorg version for ABI compatibility (numeric format)
        \\/// Format: Major * 1_000_000 + Minor * 1_000 + Patch
        \\/// Example: 0.1.0 = {d}, 1.0.0 = 1_000_000
        \\/// This is used to verify auto binaries match the engine version
        \\pub const TARGET_ZORG_VERSION: u32 = {d};
        \\
    , .{ version_str, version_info.numeric, version_info.numeric }) catch @panic("Failed to format version");
    defer b.allocator.free(version_file_content);
    
    // Write version.zig file directly during build configuration
    const version_file_path = b.pathFromRoot("version.zig");
    {
        var file = std.fs.cwd().createFile(version_file_path, .{}) catch |err| {
            std.log.err("Failed to create version.zig: {}", .{err});
            @panic("Could not create version.zig");
        };
        defer file.close();
        file.writeAll(version_file_content) catch |err| {
            std.log.err("Failed to write version.zig: {}", .{err});
            @panic("Could not write version.zig");
        };
    }

    const vaxis = b.dependency("vaxis", .{
        .target = target,
        .optimize = optimize,
    });

    const version_mod = b.createModule(.{
        .root_source_file = b.path("version.zig"),
        .target = target,
        .optimize = optimize,
    });

    const zdk_mod = b.createModule(.{
        .root_source_file = b.path("zdk/zdk.zig"),
        .target = target,
        .optimize = optimize,
    });
    zdk_mod.addImport("version", version_mod);

    const exe = b.addExecutable(.{
        .name = "zorg",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/zorg.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    exe.root_module.addImport("vaxis", vaxis.module("vaxis"));
    exe.root_module.addImport("zdk", zdk_mod);
    exe.root_module.addImport("version", version_mod);
    exe.linkSystemLibrary("sqlite3");

    b.installArtifact(exe);

    const run_step = b.step("run", "Run the app");
    const run_cmd = b.addRunArtifact(exe);
    run_step.dependOn(&run_cmd.step);
    run_cmd.step.dependOn(b.getInstallStep());

    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const test_step = b.step("test", "Run unit tests");

    const t = b.addTest(.{
        .name = "unit_tests",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/zorg.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    t.root_module.addImport("zdk", zdk_mod);
    t.root_module.addImport("version", version_mod);
    t.linkSystemLibrary("sqlite3");

    const run_t = b.addRunArtifact(t);
    run_t.cwd = b.path(".");

    test_step.dependOn(&run_t.step);
}
